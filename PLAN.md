# План разработки игры "The Last of Guss"

## Введение

Этот документ описывает план разработки браузерной игры "The Last of Guss", где игроки соревнуются в скорости тапов по виртуальному гусю. План разбит на этапы и блоки, которые можно последовательно реализовывать, тестировать и интегрировать. Особое внимание уделяется чистоте кода (SOLID), корректности API, масштабируемости решений и профессиональной презентации.

### Технологический стек

- **Backend:** Node.js, TypeScript (strict mode), NestJS, PostgreSQL, Prisma ORM.
- **Frontend:** React, TypeScript, React Router, Vite, Shadcn/UI (с Tailwind CSS), Zustand (или аналогичный легкий стейт-менеджер).
- **Аутентификация:** JWT токены в HttpOnly куках.

### Архитектурные особенности

- **Масштабируемость:** Бекенд спроектирован для работы с несколькими инстансами (один экземпляр БД, несколько экземпляров Node.js-приложения за реверс-прокси). Отсутствие привязки сессии пользователя к конкретному инстансу.
- **Консистентность данных:** Использование транзакций и механизмов блокировок (если потребуется на уровне БД) для обеспечения целостности данных при одновременных тапах.
- **Деплоймент:** Предполагается запуск `node dist/index.js`. Dockerfile и docker-compose не требуются, но в документации будет указана предполагаемая архитектура развертывания.

### Команды для запуска (после установки зависимостей):

- `npm install` (установить зависимости)
- `npm run build` (собрать проект)
- `npm start` (запустить проект)
- `npm test` (запустить тесты)

### Документация (README.md для GitHub)

Будет содержать следующую структуру:

1.  **Название проекта**
2.  **Описание игры**
3.  **Демонстрация** (ссылки на работающий проект, если доступно)
4.  **Стек технологий**
5.  **Архитектура**
6.  **Установка и запуск**
7.  **API Документация** (сгенерированная или краткое описание эндпоинтов)
8.  **План разработки** (краткий обзор выполненных этапов)
9.  **Особенности реализации** (консистентность, масштабирование)
10. **Авторы**

---

## Этапы разработки

### Этап 0: Подготовка проекта и базовые структуры

**Цель:** Инициализация проектов, настройка окружения, создание базовых файлов и структур.

**Блок 0.1: Инициализация Backend (NestJS, TypeScript, Prisma)**

- **Инструкции для человека:**
  - Создать новый проект NestJS.
  - Настроить TypeScript с `strict: true`.
  - Установить и настроить Prisma ORM.
  - Создать базовую структуру папок (например, `src/modules`, `src/common`, `src/database`).
  - Создать `.env` файл для подключения к базе данных.
  - Настроить скрипты `package.json` для сборки и запуска.
- **Инструкции для генератора кода:**
  - `nest new the-last-of-guss-backend --strict --package-manager npm`
  - `npm install @nestjs/config prisma @prisma/client`
  - `npx prisma init --datasource-provider postgresql`
  - Добавить в `src/main.ts` валидацию глобальных пайпов и DTO.
  - Создать базовый `AppModule` и `AppService`.
  - Настроить `.env` c `DATABASE_URL` и `ROUND_DURATION`, `COOLDOWN_DURATION`.
- **Ожидаемый результат:** Готовый к разработке бекенд-проект с настроенным NestJS, TypeScript, Prisma и базовой конфигурацией.
- **Тестирование:** Проверить, что проект собирается (`npm run build`) и запускается (`npm start`).

**Блок 0.2: Инициализация Frontend (React, Vite, Shadcn/UI, Tailwind CSS)**

- **Инструкции для человека:**
  - Создать новый проект React с Vite и TypeScript.
  - Установить и настроить Tailwind CSS.
  - Инициализировать Shadcn/UI.
  - Настроить React Router.
  - Создать базовую структуру папок (например, `src/components`, `src/pages`, `src/lib`, `src/hooks`).
  - Добавить favicon.
- **Инструкции для генератора кода:**
  - `npm create vite@latest the-last-of-guss-frontend -- --template react-ts`
  - `cd the-last-of-guss-frontend`
  - `npm install -D tailwindcss postcss autoprefixer`
  - `npx tailwindcss init -p` (настроить `tailwind.config.js`)
  - `npx shadcn-ui@latest init` (выбрать Tailwind CSS, React)
  - `npm install react-router-dom`
  - Создать базовый `App.tsx` с `BrowserRouter` и placeholder для роутов.
- **Ожидаемый результат:** Готовый к разработке фронтенд-проект с настроенными React, Vite, TypeScript, Tailwind CSS, Shadcn/UI и React Router.
- **Тестирование:** Проверить, что проект собирается (`npm run build`) и запускается (`npm run dev`).

---

### Этап 1: Аутентификация и управление пользователями

**Цель:** Реализовать систему регистрации/входа пользователей с ролями и защищенные API-эндпоинты.

**Блок 1.1: Модель пользователя и Prisma Schema**

- **Инструкции для человека:**
  - Определить модель `User` в `schema.prisma` с полями `id`, `username`, `passwordHash`, `role`.
  - Добавить перечисление `Role` (User, Admin, Nikita).
  - Применить миграцию Prisma.
- **Инструкции для генератора кода:**

  - **File: `prisma/schema.prisma`**

    ```prisma
    enum Role {
      USER
      ADMIN
      NIKITA
    }

    model User {
      id           String    @id @default(uuid())
      username     String    @unique
      passwordHash String
      role         Role      @default(USER)
      taps         Tap[]
    }

    model Round {
      id        String   @id @default(uuid())
      startTime DateTime
      endTime   DateTime
      isActive  Boolean  @default(false)
      taps      Tap[]
      // totalTaps Int      @default(0) // Возможно, будем считать динамически или кешировать
      // totalScore Int      @default(0) // Возможно, будем считать динамически или кешировать
    }

    model Tap {
      id        String   @id @default(uuid())
      userId    String
      roundId   String
      score     Int
      createdAt DateTime @default(now())
      user      User     @relation(fields: [userId], references: [id])
      round     Round    @relation(fields: [roundId], references: [id])
    }
    ```

  - `npx prisma db push --preview-feature` (для быстрой итерации, на проде использовать миграции)
  - `npx prisma generate`

- **Ожидаемый результат:** Готовая модель данных для пользователей, сгенерированные Prisma-клиенты.
- **Тестирование:** Проверить, что таблицы созданы в базе данных.

**Блок 1.2: Модуль аутентификации (AuthModule)**

- **Инструкции для человека:**
  - Создать `AuthModule` с `AuthService`, `AuthRepository` (или использовать `PrismaService`), `AuthController`.
  - Реализовать эндпоинты для регистрации (`/auth/register`) и входа (`/auth/login`).
  - Использовать `bcrypt` для хеширования паролей.
  - Генерация JWT токенов. Токены хранить в `HttpOnly` куках для безопасности.
  - При регистрации:
    - Если `username` === 'admin', то `role` = `ADMIN`.
    - Если `username` === 'Никита', то `role` = `NIKITA`.
    - Иначе `role` = `USER`.
- **Инструкции для генератора кода:**
  - **File: `src/auth/auth.module.ts`**
    ```typescript
    // ... imports
    @Module({
      imports: [
        UsersModule, // Предполагается, что UserModule будет создан позже
        PassportModule,
        JwtModule.register({
          secret: process.env.JWT_SECRET || "your_secret_key",
          signOptions: { expiresIn: "1h" },
        }),
      ],
      providers: [AuthService, JwtStrategy], // JwtStrategy будет создан позже
      controllers: [AuthController],
    })
    export class AuthModule {}
    ```
  - **File: `src/auth/auth.service.ts`** (содержит логику регистрации, входа, хеширования паролей, генерации JWT)
  - **File: `src/auth/auth.controller.ts`** (эндпоинты `/register`, `/login`)
  - **File: `src/auth/dto/register.dto.ts`, `src/auth/dto/login.dto.ts`** (DTO для валидации ввода)
- **Ожидаемый результат:** Функционирующая система регистрации и входа с выдачей JWT токенов в `HttpOnly` куках.
- **Тестирование:**
  - Написать юнит-тесты для `AuthService` (хеширование, генерация токенов).
  - Написать E2E тесты для `AuthController` (регистрация нового пользователя, вход существующего, проверка ролей по имени).
  - Проверить, что `Никита` получает роль `NIKITA`, `admin` - `ADMIN`, остальные - `USER`.

**Блок 1.3: JWT стратегия и Guards**

- **Инструкции для человека:**
  - Реализовать `JwtStrategy` для NestJS Passport, извлекающий токен из куки.
  - Создать `JwtAuthGuard` для защиты эндпоинтов.
  - Создать `RolesGuard` для авторизации по ролям.
- **Инструкции для генератора кода:**
  - **File: `src/auth/jwt.strategy.ts`** (извлекает JWT из запроса, валидирует, возвращает `user` объект).
  - **File: `src/auth/jwt-auth.guard.ts`** (базовый Guard для аутентификации).
  - **File: `src/auth/roles.guard.ts`** (Guard, который проверяет `@Roles()` декоратор).
  - **File: `src/auth/roles.decorator.ts`** (декоратор `@Roles()` для указания требуемых ролей на эндпоинтах).
- **Ожидаемый результат:** Рабочая система аутентификации и авторизации на основе JWT и ролей.
- **Тестирование:**
  - Написать юнит-тесты для `JwtStrategy` (валидация токена).
  - Написать E2E тесты, проверяющие доступ к защищенным эндпоинтам с корректными и некорректными токенами/ролями.

**Блок 1.4: Модуль пользователей (UsersModule) (Back-end)**

- **Инструкции для человека:**
  - Создать `UsersModule` с `UsersService` и `UsersRepository` (или использовать `PrismaService`).
  - `UsersService` будет отвечать за операции с пользователями (поиск по имени, создание).
  - Интегрировать `UsersModule` в `AuthModule`.
- **Инструкции для генератора кода:**
  - **File: `src/users/users.module.ts`**
  - **File: `src/users/users.service.ts`** (методы `findByUsername`, `create`).
  - **File: `src/users/users.repository.ts`** (опционально, если не используется `PrismaService` напрямую).
- **Ожидаемый результат:** Слой для работы с данными пользователей, интегрированный в систему аутентификации.
- **Тестирование:** Юнит-тесты для `UsersService` (создание, поиск пользователя).

---

### Этап 2: Управление раундами

**Цель:** Реализовать создание, получение и управление состояниями раундов.

**Блок 2.1: Модель раунда и Prisma Schema (дополнение)**

- **Инструкции для человека:**
  - В `prisma/schema.prisma` добавить модель `Round` с полями `id`, `startTime`, `endTime`.
  - Учесть, что `ROUND_DURATION` и `COOLDOWN_DURATION` берутся из `.env` при старте приложения.
  - Применить миграцию Prisma.
- **Инструкции для генератора кода:**
  - **File: `prisma/schema.prisma`** (уже было в Блоке 1.1)
    ```prisma
    model Round {
      id          String   @id @default(uuid())
      startTime   DateTime
      endTime     DateTime
      createdAt   DateTime @default(now())
      status      String   @default("COOLDOWN") // ACTIVE, COMPLETED, COOLDOWN
      // Дополнительные поля для статистики, если не считаются динамически
      // totalTaps   Int      @default(0)
      // totalScore  Int      @default(0)
      // winnerId    String?
      // winnerScore Int?
    }
    ```
  - `npx prisma db push --preview-feature`
  - `npx prisma generate`
- **Ожидаемый результат:** Модель данных для раундов.
- **Тестирование:** Проверить, что таблицы созданы.

**Блок 2.2: Модуль раундов (RoundsModule) и создание раунда**

- **Инструкции для человека:**
  - Создать `RoundsModule` с `RoundsService`, `RoundsRepository` и `RoundsController`.
  - Реализовать эндпоинт `POST /rounds` для создания раунда. Доступен только для `ADMIN` роли.
  - При создании раунда:
    - `startTime` рассчитывается как `now() + COOLDOWN_DURATION`.
    - `endTime` рассчитывается как `startTime + ROUND_DURATION`.
  - Использовать `ConfigService` NestJS для чтения `ROUND_DURATION` и `COOLDOWN_DURATION` из `.env`.
- **Инструкции для генератора кода:**
  - **File: `src/rounds/rounds.module.ts`**
  - **File: `src/rounds/rounds.service.ts`** (метод `createRound`).
  - **File: `src/rounds/rounds.controller.ts`** (`@Post()`, `@Roles(Role.ADMIN)`, `@UseGuards(JwtAuthGuard, RolesGuard)`).
  - **File: `src/rounds/dto/create-round.dto.ts`** (возможно, пустой DTO или с опциональными параметрами для будущего расширения).
  - **File: `src/config/config.module.ts`, `src/config/configuration.ts`** (для чтения переменных окружения).
- **Ожидаемый результат:** Эндпоинт для администраторов для создания нового раунда.
- **Тестирование:**
  - Юнит-тесты для `RoundsService.createRound` (проверка расчета `startTime` и `endTime`).
  - E2E тесты для `RoundsController.createRound` (проверка доступа для админа, отказ для обычных пользователей).

**Блок 2.3: Получение списка раундов и информации по конкретному раунду**

- **Инструкции для человека:**
  - Реализовать эндпоинт `GET /rounds` для получения списка всех раундов (активных, запланированных, завершенных). Доступен для всех аутентифицированных пользователей.
  - Реализовать эндпоинт `GET /rounds/:id` для получения детальной информации по конкретному раунду. Включает текущее состояние раунда (активен, кулдаун, завершен), оставшееся время, информацию о победителе (если раунд завершен), свои очки.
  - Состояние раунда определяется динамически на основе `startTime`, `endTime` и текущего времени.
  - Использовать `Prisma` для запросов с агрегациями, чтобы получить статистику по раунду и пользователю.
- **Инструкции для генератора кода:**
  - **File: `src/rounds/rounds.service.ts`** (методы `findAllRounds`, `findRoundById`).
  - **File: `src/rounds/rounds.controller.ts`** (`@Get()`, `@Get(':id')`).
  - **File: `src/rounds/dto/round.response.dto.ts`** (DTO для ответа, включает `status`, `timeLeft`, `myScore`, `winner` и т.д.).
  - Добавить логику для определения статуса раунда (`isActive`, `isCooldown`, `isCompleted`) в `RoundsService` или как метод `Round` модели.
- **Ожидаемый результат:** Эндпоинты для просмотра списка раундов и деталей по каждому раунду.
- **Тестирование:**
  - Юнит-тесты для `RoundsService` (определение статуса раунда, расчет победителя).
  - E2E тесты для `RoundsController` (получение списка раундов, получение информации по существующему и несуществующему раунду).

---

### Этап 3: Механика тапов и игровая логика

**Цель:** Реализовать основную игровую механику - тапы по гусю, с учетом консистентности и правил.

**Блок 3.1: Модель тапа и Prisma Schema (дополнение)**

- **Инструкции для человека:**
  - В `prisma/schema.prisma` добавить модель `Tap` с полями `id`, `userId`, `roundId`, `score`, `createdAt`.
  - Установить связи между `Tap` и `User`, `Tap` и `Round`.
  - Применить миграцию Prisma.
- **Инструкции для генератора кода:**
  - **File: `prisma/schema.prisma`** (уже было в Блоке 1.1)
    ```prisma
    model Tap {
      id        String   @id @default(uuid())
      userId    String
      roundId   String
      score     Int
      createdAt DateTime @default(now())
      user      User     @relation(fields: [userId], references: [id])
      round     Round    @relation(fields: [roundId], references: [id])
    }
    ```
  - `npx prisma db push --preview-feature`
  - `npx prisma generate`
- **Ожидаемый результат:** Модель данных для тапов.
- **Тестирование:** Проверить, что таблицы созданы.

**Блок 3.2: Эндпоинт тапа по гусю (`POST /rounds/:id/tap`)**

- **Инструкции для человека:**
  - Реализовать эндпоинт `POST /rounds/:id/tap`. Доступен для всех аутентифицированных пользователей.
  - В логике тапа:
    1.  Проверить роль пользователя (если "Никита", то тапы не учитываются, но запрос проходит успешно, возвращая 0 очков).
    2.  Проверить, что раунд активен (текущее время между `startTime` и `endTime`).
    3.  В рамках одной транзакции:
        - Получить количество предыдущих тапов пользователя в этом раунде.
        - Определить очки за текущий тап: 1 очко, если не 11-й; 10 очков, если 11-й.
        - Создать новую запись `Tap` в базе данных.
        - (Опционально, для оптимизации) Обновить агрегированные счетчики `totalTaps`, `totalScore` в модели `Round` и `UserRoundStats` (если такие будут, иначе считать динамически). **Важно учесть race conditions.** Использовать изоляцию транзакций или механизмы блокировки на уровне БД (например, `SELECT FOR UPDATE` если нужна очень высокая консистентность, но для 10 пользователей может быть излишне).
  - Возвращать текущее количество очков пользователя в данном раунде.
- **Инструкции для генератора кода:**
  - **File: `src/rounds/rounds.controller.ts`** (`@Post(':id/tap')`).
  - **File: `src/rounds/rounds.service.ts`** (метод `handleTap`).
  - **File: `src/taps/taps.module.ts`, `src/taps/taps.service.ts`** (возможно, отдельный модуль для логики тапов, чтобы отделить concerns).
  - Использовать `@nestjs/platform-express` для доступа к `req.user` (получение ID пользователя из JWT).
  - **File: `src/common/interceptors/transaction.interceptor.ts`** (опционально, для автоматического управления транзакциями).
  - Добавить логику для расчета очков и проверки условий.
- **Ожидаемый результат:** Функционирующий эндпоинт для тапов по гусю с корректной обработкой правил, ролей и консистентностью данных.
- **Тестирование:**
  - Юнит-тесты для логики расчета очков (`TapsService`).
  - E2E тесты для `RoundsController.handleTap`:
    - Обычный пользователь тапает в активном раунде.
    - "Никита" тапает (проверить, что очки 0).
    - Пользователь тапает в неактивном раунде (ожидается ошибка).
    - Тесты на race conditions (например, с помощью `Promise.all` для параллельных запросов), чтобы убедиться в корректности подсчета очков.

---

### Этап 4: Фронтенд: UI и интеграция API

**Цель:** Реализовать пользовательский интерфейс и подключить его к разработанному API.

**Блок 4.1: Компоненты UI (v0.app)**

- **Инструкции для человека:**
  - Использовать `v0.app` для генерации следующих компонентов, затем интегрировать их с Shadcn/UI и Tailwind:
    - **Login Form:** Форма с полями "Имя пользователя", "Пароль" и кнопкой "Войти". Должно быть поле для сообщения об ошибке.
    - **Round List Item:** Карточка для отображения информации о раунде: ID, Start/End Time, Status. Должен быть кликабельным (ссылка).
    - **Create Round Button:** Кнопка "Создать раунд", видимая только для админов.
    - **Round Details Header:** Заголовок страницы раунда с текущим статусом и оставшимся временем.
    - **Guss Image:** Изображение гуся (можно использовать ASCII-арт или простой SVG), по которому можно тапать.
    - **Tap Counter & Score:** Компоненты для отображения "Мои очки" и "Всего тапов в раунде".
    - **Leaderboard / Winner Display:** Компонент для отображения победителя и общей статистики раунда.
- **Инструкции по интеграции:**
  - Для каждого сгенерированного компонента:
    - Скопировать HTML/TSX код в `src/components`.
    - Применить стили Tailwind CSS.
    - Заменить стандартные HTML-элементы на компоненты Shadcn/UI (например, `<input>` на `<Input>`, `<button>` на `<Button>`).
    - Интегрировать логику состояния и пропсы.
- **Ожидаемый результат:** Набор готовых, стилизованных UI-компонентов.
- **Тестирование:** Визуальная проверка компонентов в Storybook (если используется) или на тестовых страницах.

**Блок 4.2: Страница логина (Login Page)**

- **Инструкции для человека:**
  - Создать страницу `LoginPage` с формой логина/регистрации.
  - При отправке формы отправлять запрос на `POST /auth/login` или `POST /auth/register`.
  - Обрабатывать успешный вход (перенаправление на страницу списка раундов) и ошибки (отображение сообщения).
  - Использовать `react-hook-form` для управления формой и валидации.
- **Инструкции для генератора кода:**
  - **File: `src/pages/LoginPage.tsx`**
  - **File: `src/api/auth.ts`** (функции для взаимодействия с API аутентификации).
  - **File: `src/hooks/useAuth.ts`** (кастомный хук для управления состоянием аутентификации пользователя, используя `zustand`).
- **Ожидаемый результат:** Рабочая страница логина и регистрации.
- **Тестирование:**
  - Проверка успешного входа/регистрации.
  - Проверка обработки ошибок (неверный пароль, пользователь уже существует).
  - Проверка редиректа после успешного входа.

**Блок 4.3: Страница списка раундов (Rounds List Page)**

- **Инструкции для человека:**
  - Создать страницу `RoundsListPage`.
  - При загрузке страницы:
    - Отправить запрос на `GET /rounds` для получения списка раундов.
    - Отобразить раунды, используя компонент `RoundListItem`.
    - Если пользователь - админ, отобразить кнопку "Создать раунд". При нажатии на кнопку отправлять `POST /rounds` и перенаправлять на страницу нового раунда.
  - Реализовать навигацию по ссылкам на страницы отдельных раундов.
- **Инструкции для генератора кода:**
  - **File: `src/pages/RoundsListPage.tsx`**
  - **File: `src/api/rounds.ts`** (функции для взаимодействия с API раундов).
  - Использование `useQuery` из `react-query` (или аналога) для кеширования и управления состоянием данных.
- **Ожидаемый результат:** Страница со списком раундов, возможностью создания нового раунда для админа.
- **Тестирование:**
  - Проверка загрузки и отображения списка раундов.
  - Проверка видимости кнопки "Создать раунд" для админа/пользователя.
  - Проверка перехода на страницу раунда.

**Блок 4.4: Страница раунда (Round Details Page)**

- **Инструкции для человека:**
  - Создать страницу `RoundDetailsPage`.
  - При загрузке страницы:
    - Отправить запрос на `GET /rounds/:id` для получения детальной информации по раунду.
    - Отобразить состояние раунда (Активен, Cooldown, Завершен).
    - Отобразить оставшееся время с таймером, обновляющимся каждую секунду.
    - Если раунд активен, отобразить гуся, по которому можно тапать.
      - При тапе отправлять `POST /rounds/:id/tap`.
      - Обновлять "Мои очки" после каждого успешного тапа.
    - Если раунд завершен, отобразить статистику раунда и победителя.
- **Инструкции для генератора кода:**
  - **File: `src/pages/RoundDetailsPage.tsx`**
  - Использование `useParams` из `react-router-dom` для получения `id` раунда.
  - **File: `src/hooks/useRoundTimer.ts`** (кастомный хук для таймера обратного отсчета).
  - Логика для обработки тапов и обновления UI.
  - Использование `WebSocket` (опционально, но лучше для real-time обновления) или частый polling для обновления данных о раунде и очках. Для тестового задания достаточно polling раз в несколько секунд и обновление собственных очков сразу после тапа.
- **Ожидаемый результат:** Интерактивная страница раунда с отображением состояния, таймером и возможностью тапать.
- **Тестирование:**
  - Проверка отображения разных состояний раунда (активен, кулдаун, завершен).
  - Проверка работы таймера.
  - Проверка тапов по гусю и обновления очков.
  - Проверка отображения победителя и статистики для завершенного раунда.

---

### Этап 5: Доработка, оптимизация и документация

**Цель:** Завершить проект, улучшить код, написать документацию и подготовить к презентации.

**Блок 5.1: Общие доработки и улучшения**

- **Инструкции для человека:**
  - Провести рефакторинг кода, убедиться в соблюдении SOLID принципов.
  - Добавить логирование (например, с помощью `pino` или встроенного NestJS-логгера).
  - Добавить обработку ошибок на всех уровнях (глобальный фильтр исключений в NestJS, `ErrorBoundary` во фронтенде).
  - Добавить PWA манифест для лучшего пользовательского опыта (опционально).
  - Использовать ESLint и Prettier для поддержания чистоты кода.
- **Инструкции для генератора кода:**
  - **File: `src/main.ts`** (для глобального `ValidationPipe`, `Logger`, `HttpExceptionFilter`).
  - **File: `src/common/filters/http-exception.filter.ts`**
  - Настроить `eslint.json`, `prettier.json`.
- **Ожидаемый результат:** Более стабильное, надежное и чистое приложение.
- **Тестирование:** Повторное прохождение всех E2E тестов, проверка логирования и обработки ошибок.

**Блок 5.2: README.md и API Документация**

- **Инструкции для человека:**
  - Написать подробный `README.md` файл для GitHub.
  - Включить разделы: "Установка и запуск", "API Эндпоинты", "Предполагаемая архитектура развертывания", "Особенности реализации" (масштабируемость, консистентность).
  - Для API использовать Swagger (NestJS интегрируется легко) или вручную описать все эндпоинты с примерами запросов/ответов.
- **Инструкции для генератора кода:**
  - **File: `README.md`** (содержит вышеуказанные разделы).
  - **File: `src/main.ts`** (добавить `SwaggerModule.setup` для документации).
  - Добавить декораторы `@Api*` к контроллерам и DTO.
- **Ожидаемый результат:** Полная и понятная документация для проекта.
- **Тестирование:** Проверить, что `README.md` содержит всю необходимую информацию, а Swagger UI доступен и корректно отображает API.

**Блок 5.3: Подготовка к презентации**

- **Инструкции для человека:**
  - Сделать скриншоты или короткое видео работы приложения.
  - Убедиться, что фронтенд выглядит профессионально и соответствует мокапам.
  - Подготовить краткое описание архитектуры и ключевых решений.
- **Ожидаемый результат:** Готовность к успешной презентации проекта.
- **Тестирование:** Финальный просмотр приложения, проверка UI/UX.

---

Вот мокапы, которые можно использовать в v0.app, для генерации компонентов. После генерации, необходимо будет интегрировать их, заменяя стандартные HTML-элементы на компоненты Shadcn/UI и применяя Tailwind классы.

### Задачи для v0.app (по компонентам):

1.  **Компонент: `LoginForm`**

    - **Описание:** "A simple login form with 'Username' and 'Password' input fields, a 'Login' button, and a placeholder for an error message below the button. The form should be visually appealing and modern."
    - **Инструкции по интеграции:**
      - Заменить `input` на `<Input />` из Shadcn/UI.
      - Заменить `button` на `<Button />` из Shadcn/UI.
      - Использовать `Label` из Shadcn/UI для меток полей.
      - Применить классы Tailwind для центрирования и отступов.

2.  **Компонент: `RoundListItem`**

    - **Описание:** "A card displaying round information: 'Round ID: [UUID]', 'Start: [Date, Time]', 'End: [Date, Time]', 'Status: [Active/Cooldown/Completed]'. The card should have a clear border, internal padding, and the Round ID should be visually highlighted as a clickable link. Include a separator line before the status."
    - **Инструкции по интеграции:**
      - Использовать `<Card />`, `<CardHeader />`, `<CardContent />` из Shadcn/UI.
      - Текст стилизовать с помощью классов Tailwind.
      - Для статуса использовать `<Badge />` из Shadcn/UI, меняющий цвет в зависимости от статуса (например, `variant="success"` для активного, `variant="secondary"` для кулдауна).

3.  \*\*Компонент: `CreateRoundButton`

    - **Описание:** "A simple, prominent button labeled 'Создать раунд'. It should be easily distinguishable and positioned for administrative actions."
    - **Инструкции по интеграции:**
      - Использовать `<Button />` из Shadcn/UI (например, `variant="default"`).
      - Применить классы Tailwind для расположения (например, `float-right` или `ml-auto`).

4.  **Компонент: `RoundDetailsHeader`**

    - **Описание:** "A header section for a round page. It should display 'Раунд активен!' (or 'Cooldown', 'Раунд завершен!') prominently. Below that, display 'До конца осталось: 00:23' (or 'до начала раунда', 'Имя игрока'). The 'Имя игрока' should always be visible in the top right corner."
    - **Инструкции по интеграции:**
      - Использовать `h1`, `h2` для заголовков.
      - Стилизовать текст с помощью классов Tailwind для размера и цвета.
      - Для таймера использовать `<Countdown />` компонент (если есть) или просто `<span>` с обновлением.
      - Имя игрока можно отобразить в `<Badge />` или просто `<span>`.

5.  **Компонент: `GussImage`**

    - **Описание:** "A central, large, ASCII-art style image of a goose. It should be tap-able, with a subtle visual feedback on tap (e.g., a slight scale change or a border flash). The image should be centered on the page."
    - **Инструкции по интеграции:**
      - Использовать `<div />` с `pre` тегом для ASCII-арта.
      - Применить классы Tailwind для центрирования (`mx-auto`, `text-center`).
      - Использовать CSS-анимации или `framer-motion` для эффекта тапа.
      - Добавить `onClick` обработчик.

6.  **Компонент: `TapScoreDisplay`**

    - **Описание:** "A section displaying 'Мои очки - [число]' and potentially 'Всего тапов - [число]' (или 'Всего: [число]' для общего счета). These should be updated dynamically and clearly visible below the Guss image."
    - **Инструкции по интеграции:**
      - Использовать `div` или `p` элементы.
      - Стилизовать текст с помощью классов Tailwind для размера и цвета.

7.  **Компонент: `WinnerDisplay`**

    - **Описание:** "For a completed round, display 'Всего [общее количество тапов]' and 'Победитель - [Имя игрока] [очки победителя]' and 'Мои очки [мои очки]'. These should be clearly presented, possibly within a `Card` or a dedicated section."
    - **Инструкции по интеграции:**
      - Использовать `<Card />`, `<CardContent />` для оформления.
      - Текст стилизовать с помощью классов Tailwind.

---

### Общие рекомендации по разработке для каждого блока:

- **Чистый код и SOLID:** Придерживайтесь принципов SOLID. Используйте явные интерфейсы, инъекцию зависимостей, старайтесь, чтобы каждый класс/функция выполняли одну задачу.
- **Типизация (TypeScript):** Максимально используйте TypeScript для всех данных, DTO, возвращаемых значений функций.
- **Тестирование:** Пишите тесты для каждого блока. Юнит-тесты для сервисов, E2E тесты для контроллеров и интеграционные тесты для фронтенда. Mock-тесты для внешних зависимостей.
- **Комментарии:** Все важные блоки кода, сложные алгоритмы и API эндпоинты должны быть снабжены подробными комментариями на английском языке для ясности.
- **Производительность:** Для работы с базой данных старайтесь минимизировать количество запросов. Используйте `include` и `select` в Prisma для выборки только необходимых данных.
- **Безопасность:**
  - Используйте хеширование паролей (`bcrypt`).
  - Храните JWT токены в `HttpOnly` куках для защиты от XSS.
  - Валидируйте все входящие данные (DTO).
  - Избегайте прямого вывода пользовательского ввода на страницу (защита от XSS на фронтенде).
- **Ограниченное время:** Если что-то слишком сложно или трудоемко, выбирайте более простые, но функциональные решения. Например, для race conditions на 10 пользователей достаточно транзакций Prisma, без явных блокировок на уровне БД.
